package com.datanova.langgraph.state;

import org.bsc.langgraph4j.state.AgentState;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * WorkflowState represents the state that flows through the LangGraph workflow.
 *
 * <p>Extends AgentState from org.bsc.langgraph4j to be compatible with the library's
 * state management. This class provides type-safe accessor methods for commonly used
 * state keys while maintaining the flexibility of a Map-based data structure.</p>
 *
 * <p>The state accumulates information as it flows through the workflow nodes:
 * <ul>
 *   <li>Input data (query, numbers)</li>
 *   <li>Planning information (plan)</li>
 *   <li>Routing decisions (currentStep, nextNode, routerDecision)</li>
 *   <li>Computation results (sum, average, fahrenheit)</li>
 *   <li>Final output (finalAnswer, complete)</li>
 * </ul>
 * </p>
 *
 * @author DataNova
 * @version 1.0
 * @see org.bsc.langgraph4j.state.AgentState
 */
public class WorkflowState extends AgentState {

    /** Key for the user's natural language query */
    public static final String QUERY_KEY = "query";

    /** Key for the list of numerical inputs */
    public static final String NUMBERS_KEY = "numbers";

    /** Key for the execution plan generated by PlannerNode */
    public static final String PLAN_KEY = "plan";

    /** Key for the name of the currently executing or last executed node */
    public static final String CURRENT_STEP_KEY = "currentStep";

    /** Key for the next node to execute as determined by RouterNode */
    public static final String NEXT_NODE_KEY = "nextNode";

    /** Key for the LLM's routing decision rationale */
    public static final String ROUTER_DECISION_KEY = "routerDecision";

    /** Key for the calculated sum of numbers */
    public static final String SUM_KEY = "sum";

    /** Key for the calculated average of numbers */
    public static final String AVERAGE_KEY = "average";

    /** Key for temperature in Fahrenheit after conversion */
    public static final String FAHRENHEIT_KEY = "fahrenheit";

    /** Key for the final summarized answer */
    public static final String FINAL_ANSWER_KEY = "finalAnswer";

    /** Key for the completion flag indicating workflow has finished */
    public static final String COMPLETE_KEY = "complete";

    /**
     * Constructs a new WorkflowState with an empty data map.
     */
    public WorkflowState() {
        super(new HashMap<>());
    }

    /**
     * Constructs a WorkflowState with the given data map.
     *
     * @param data initial state data
     */
    public WorkflowState(Map<String, Object> data) {
        super(data);
    }

    /**
     * Gets the user's natural language query.
     *
     * @return the query string, or null if not set
     */
    public String query() {
        return (String) data().get(QUERY_KEY);
    }

    /**
     * Gets the list of numerical inputs to process.
     *
     * @return list of Double values, or null if not set
     */
    public List<Double> numbers() {
        return (List<Double>) data().get(NUMBERS_KEY);
    }

    /**
     * Gets the execution plan generated by the PlannerNode.
     *
     * @return the plan string, or null if not generated yet
     */
    public String plan() {
        return (String) data().get(PLAN_KEY);
    }

    /**
     * Gets the name of the currently executing or last executed node.
     *
     * @return the node name, or null if not set
     */
    public String currentStep() {
        return (String) data().get(CURRENT_STEP_KEY);
    }

    /**
     * Gets the next node to execute as determined by the RouterNode.
     *
     * @return the next node name, or null if not determined yet
     */
    public String nextNode() {
        return (String) data().get(NEXT_NODE_KEY);
    }

    /**
     * Gets the LLM's routing decision rationale.
     *
     * @return the decision rationale, or null if not available
     */
    public String routerDecision() {
        return (String) data().get(ROUTER_DECISION_KEY);
    }

    /**
     * Gets the calculated sum of numbers.
     *
     * @return the sum, or null if not calculated yet
     */
    public Double sum() {
        return (Double) data().get(SUM_KEY);
    }

    /**
     * Gets the calculated average of numbers.
     *
     * @return the average, or null if not calculated yet
     */
    public Double average() {
        return (Double) data().get(AVERAGE_KEY);
    }

    /**
     * Gets the temperature in Fahrenheit after conversion.
     *
     * @return the Fahrenheit temperature, or null if not converted yet
     */
    public Double fahrenheit() {
        return (Double) data().get(FAHRENHEIT_KEY);
    }

    /**
     * Gets the final summarized answer from the SummarizerNode.
     *
     * @return the final answer, or null if not generated yet
     */
    public String finalAnswer() {
        return (String) data().get(FINAL_ANSWER_KEY);
    }

    /**
     * Checks if the workflow has completed.
     *
     * @return true if complete, false or null otherwise
     */
    public Boolean complete() {
        return (Boolean) data().get(COMPLETE_KEY);
    }
}
